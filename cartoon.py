# -*- coding: utf-8 -*-
"""Cartoon

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h-QEWqwIngrwCPyOsI9B-oV1HNOtQwvX
"""

import cv2
import os
import numpy as np
from numpy import asarray
import math
import PIL
from PIL import Image
import matplotlib.pyplot as plt
import scipy.misc

def show_image(image, title=None, style=None):
    plt.figure(figsize=(8, 8))
    if title:
        plt.title(title)
    plt.imshow(image, cmap=style)
    plt.show()

def conv2D(image: np.array, kernel: np.array = None ):
    kerShape = kernel.shape 
    imShape = image.shape
    padding = int((kerShape[0]-1)/2) # how many zeros to pad edges with. only take [0] b/c we assume kernel square
    paddedIm = np.zeros((imShape[0] + 2*padding, imShape[1] + 2*padding),float)
    
    for i in range(imShape[0]):
        for j in range(imShape[1]):
            paddedIm[padding + i][padding + j] = image[i][j] #form padded image by placing image in between 0 borders
    
    h = np.zeros(kerShape,float)
    
    for i in range(kerShape[0]):
        h[i] = kernel[(kerShape[0]-1) - i]
        
    padImShape = paddedIm.shape 
    
    convIm = np.zeros(imShape,float)
    kerCenterX = int((kerShape[0]-1)/2)
    kerCenterY = int((kerShape[1]-1)/2)
    k = int((kerShape[0]-1)/2) # used for indexing kernel 
    
    temp = np.zeros((kerShape[0],kerShape[1]),float)
    
    for i in range(imShape[0]):
        for j in range(imShape[1]):
                for m in range(-k,k+1): #k+1
                    for n in range(-k,k+1): #k+1
                        ii = padding + i
                        jj = padding + j
                        temp[m+k][n+k] = h[kerCenterX + m][kerCenterY + n]*paddedIm[ii-m][jj-n] #+
                        convIm[i][j] = temp.sum()
                        #convIm[i][j] += h[kerCenterX + m][kerCenterY + n]*paddedIm[ii-m][jj-n]
                        
    
    return convIm

def sharpen(image):
  kernel = np.array([[-1, -1, -1], [-1, 9, -1], [-1, -1, -1]])
  sharpened = np.zeros(image.shape,image.dtype)
  sharpened[:,:,0] = conv2D(image[:,:,0],kernel)
  sharpened[:,:,1] = conv2D(image[:,:,1],kernel)
  sharpened[:,:,2] = conv2D(image[:,:,2],kernel)

  return sharpened

def laplaceEdge(image):
  kernel = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]])
  edges = np.zeros(image.shape,image.dtype)
  edges[:,:,0] = conv2D(image[:,:,0],kernel)
  edges[:,:,1] = conv2D(image[:,:,1],kernel)
  edges[:,:,2] = conv2D(image[:,:,2],kernel)

  return edges

def color_quantization(img, k):
# Transform the image
  data = np.float32(img).reshape((-1, 3))

# Determine criteria
  criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 20, 0.001)

# Implementing K-Means
  ret, label, center = cv2.kmeans(data, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
  center = np.uint8(center)
  result = center[label.flatten()]
  result = result.reshape(img.shape)
  return result

def BF_Median(image):
    d1 = 3
    d2 = 7
    #fin = cv2.bilateralFilter(cv2.medianBlur(image,d1), d2, sigmaColor=200,sigmaSpace=200)
    fin = cv2.bilateralFilter(image, d2, sigmaColor=1,sigmaSpace=1) #1, 2, 20,200
    return fin

def paintify(image_path,save_path):
  image = Image.open(image_path)
  #image1 = laplaceEdge(image)
  count = 1
  #for numColor in range(3,10): #3
  numColor = 3
  while numColor < 10: #10: #15
    filtered = asarray(image)
    filtered = color_quantization(filtered, numColor)
    for j in range(3):
      filtered = BF_Median(filtered)
    show_image(filtered)
    save_name = image_name[:-4] + str(count) + image_name[-4:]
    matplotlib.image.imsave(save_path + save_name, filtered)
    count = int(count) + 1
    if numColor >=5 :
      numColor = numColor + 2
      #numColor = numColor + 1
    else:
      numColor = numColor + 1

image_name = ''

image_path = 'IMG_PATH' + image_name
save_path = 'PATH_TO_SAVE_FOLDER'

paintify(image_path,save_path)